branch: days_002

性能测试结果并不够好，我认为可能是因为 workers 都消费同一个 TaskQueue 导致的，这里需要用到太多锁

改进方式：

1. 去掉 GoPool.TaskQueue，在 AddTask 的时候，直接将 Task 丢给 Worker.TaskQueue；
2. Worker 中保留一个容量为1的 Task Channel；
3. AddTask 需要从 GoPool.Workers 中检索出来一个空闲的 Worker，当 Worker 完成 Task 处理后，需要能够被放回 GoPool，因此你需要考虑将 workers 实现成一个栈，添加对应的入栈出栈方法

最终实现：

1. GoPool 结构体中的 TaskQueue 被移除了，每个 Worker 都有自己的 TaskQueue
2. AddTask 方法会将任务添加到一个空闲的 Worker 的 TaskQueue 中。Release 方法会关闭所有 Worker 的 TaskQueue
3. 添加了 popWorker 和 pushWorker 方法，用于从 workerStack 中取出和放回 Worker。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_003

问题: 没有考虑到当 workers 耗尽的时候 AddTask 方法应该怎么办，显然继续执行 popWorker() 会导致 slice 越界

改进方式:  
GoPool 中添加一个容量非常大的 Channel 来保存来不及分发给 Worker 的 tasks，然后在一个单独的 goroutine 中监听这个 Channel，不断尝试获取空闲的 Worker，将 Channel 中的任务分发给空闲的 workers

最终实现: 
GoPool 结构体中添加了一个 taskQueue，用于保存来不及分发给 Worker 的任务。
添加了 dispatch 方法，用于在一个单独的 goroutine 中监听 taskQueue，并将任务分发给空闲的 Worker。
AddTask 方法现在只是将任务添加到 taskQueue 中。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_004

问题: 没有优雅退出, 在调用Release()方法的时候，可能有worker的任务虽然从channel中取出了，但是还没执行完成

改进方式:
为了实现优雅关闭，我们可以在 Release 方法中添加一个循环，等待所有的 Worker 完成他们的任务。这可以通过检查 workerStack 的长度来实现，当 workerStack 的长度等于 MaxWorkers 时，说明所有的 Worker 都已经完成了他们的任务


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_005

问题:
push 和 pop 操作没有加锁，并发的时候应该会出问题，在调用Release()方法的时候，len(p.workerStack) != p.MaxWorkers 条件有问题,可以考虑加一个互斥锁；
此外 dispatch() 中的循环 sleep 看起来不太优雅，或许可以添加条件变量，当 len(p.workerStack) == 0 时进入等待；同时 Worker.start() 方法在完成 push worker 之后通过 cond.Signal() 唤醒 dispatch()

改进方式:
引入锁，执行的时候加锁；引入sync.Cond

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_006

问题：
我想尝试通过 Functional Options 模式给 GoPool 添加配置，Option 中我希望先支持配置 GoPool 中的锁是使用互斥锁还是自旋锁

改进方式：
一个开源的自旋锁的实现，地址是 github.com/daniel-hutao/spinlock
在 GoPool 结构体中将 mutex 的类型从 sync.Mutex 更改为 sync.Locker，这样我们就可以使用任何实现了 sync.Locker 接口的锁，包括 sync.Mutex 和 spinlock.SpinLock

添加一个 Option 类型的函数，该函数接受一个 *GoPool 参数并修改其属性。我们可以添加一个 WithLock 函数，该函数接受一个 sync.Locker 参数并将其设置为 GoPool 的锁。


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_007

问题：
启动的时候创建的协成池的数量是固定的，可以根据 taskQueue 的长度动态调整 workers 数量，这样更加友好
启动的时候可以手动指定参数来确定最大协成池的数量和最小数量

改进方式：
在 GoPool 结构体中添加一个新的属性 MinWorkers，并添加一个新的选项 WithMinWorkers 来配置这个属性。然后，我们需要修改 dispatch 方法以实现动态调整 worker 数量的功能。

当 taskQueue 的长度超过 (MaxWorkers - MinWorkers) / 2 + MinWorkers 时，我们可以增加 worker 数量，直到达到 MaxWorkers。当 taskQueue 的长度小于 MinWorkers 时，我们可以减少 worker 数量，直到达到 MinWorkers

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_008
问题：
不需要公开的方法和属性应该改成小写字母开头，比如 GoPool中的属性
Option 相关的代码拆分到一个新的源文件中

改进方式：
如上

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_009 --- 提交时忘了开新分支，与 days_008 分支在一起了
问题：
对于每个发送到队列中的task没有超时控制，需要增加超时控制

改进方式：
1. 增加一个 WithTimeout 函数来配置 goPool 全局超时时间，这个时间会被传递给每个 worker，当这个超时时间为 <=0 表示不超时；反之则在 worker.start 里运行 Task 的时候加入超时中断逻辑
2. Task 被中断后应该能够返回一个超时错误


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_010

问题：
task执行的时候可能会有报错或者结果返回，需要增加结果处理方法

改进方式：
使用回调函数，将task执行的错误或者结果返回保存到某个地方

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

branch: days_011

问题：
task执行失败后没有自动重试功能

改进方式：
增加重试次数，用户指定重试次数
在 goPool 结构体中添加一个新的字段 retryCount 来存储重试次数。然后，我们需要创建一个新的 Option 函数 WithRetryCount 来设置这个值。如果用户没有配置这个值，那么 retryCount 应该默认为 0，表示不进行重试


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



