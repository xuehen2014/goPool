性能测试结果并不够好，我认为可能是因为 workers 都消费同一个 TaskQueue 导致的，这里需要用到太多锁

改进方式：

1. 去掉 GoPool.TaskQueue，在 AddTask 的时候，直接将 Task 丢给 Worker.TaskQueue；
2. Worker 中保留一个容量为1的 Task Channel；
3. AddTask 需要从 GoPool.Workers 中检索出来一个空闲的 Worker，当 Worker 完成 Task 处理后，需要能够被放回 GoPool，因此你需要考虑将 workers 实现成一个栈，添加对应的入栈出栈方法

最终实现：

1. GoPool 结构体中的 TaskQueue 被移除了，每个 Worker 都有自己的 TaskQueue
2. AddTask 方法会将任务添加到一个空闲的 Worker 的 TaskQueue 中。Release 方法会关闭所有 Worker 的 TaskQueue
3. 添加了 popWorker 和 pushWorker 方法，用于从 workerStack 中取出和放回 Worker。